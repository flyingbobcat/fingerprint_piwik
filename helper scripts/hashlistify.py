#!/usr/bin/env python

import os
import hashlib
import tarfile
import versions
import pprint
import random
import time
from multiprocessing import Pool
from collections import defaultdict
import sys

dir_with_all_the_tarballs = "/mnt/ramdisk/piwiks" # needs to be set!
DEFAULT_VECTOR_TYPE = 'response status'
DEFAULT_VECTOR_VALUE = 404
OUTPUT_FILE = "/tmp/vectors.txt"
PREFIX_TO_REMOVE = "piwik"
idprefix = hex(random.randint(0x1000, 0xFFFF))
quiet=False

def md5(text):
	'''simply does the md5sum'''
	m = hashlib.md5()
	m.update(text)
	h = m.hexdigest()
	return h

def tar_create_hashlist(arg):
	# unpacking needed due to parallelization
	tarball, dir_prefix = arg

	# to be returned:
	v = versions.extract_version(tarball)
	hashlist = []

	# create the hash list
	if not quiet:
		print "open",tarball
	try:
		with tarfile.open(tarball) as f:
			members = f.getmembers()
			wanted_members = filter(lambda x: x.name.startswith(dir_prefix) and x.isfile(), members)
			for m in wanted_members:
				try:
					unpacked = f.extractfile(m).read()
				except IOError:
					if not quiet:
						print "file error", m.name
				h = md5(unpacked)
				hashlist.append([m.name, h])
	except IOError:
		if not quiet:
			print "error",tarball
		return v, None
	except KeyboardInterrupt:
		exit(-1)
	return v, hashlist
	
vindex = 1

def make_vector(files_rpath_in_web, answers_records):
	global vindex
	files_rpath_in_web = files_rpath_in_web[len(PREFIX_TO_REMOVE)] if files_rpath_in_web.startswith(PREFIX_TO_REMOVE) else files_rpath_in_web
	date = time.asctime()
	v = {
		'id'			: idprefix+"-"+str(vindex),
		'desc'			: 'Autogenerated hash matching vector for %s created at (%s)'%(files_rpath_in_web,date),
		'related'		: '',
		'url'			: files_rpath_in_web,
		'answers'		: answers_records[:]
		}
	vindex+=1
	return v

def hashlistify(relative_path):

	# prepare the parameters
	relative_path = relative_path.strip().strip("/")
	all_the_tarballs = [ os.path.join(dir_with_all_the_tarballs, tarball) for tarball in os.listdir(dir_with_all_the_tarballs) ]

	# get the hash lists in parallel
	p = Pool(20)
	try:
		ret = p.map(tar_create_hashlist, [ [tarball, relative_path] for tarball in all_the_tarballs ] )
	except KeyboardInterrupt:
		exit(-1)
	
	# temporary results are of this format:
	# [('0.6.3', [['piwik/piwik.js', '9f9ddede4f3d75b315d7aebaafecc300']]),
	# ('0.2.4', [['piwik/piwik.js', '6a62b677e0fa5543226c44435c5d08fa']]),
	# ('2.9.0-rc1', [['piwik/piwik.js', 'dea49cb63800f80094426e8c08797654']]),
	# ('2.9.0-b9', [['piwik/piwik.js', 'dea49cb63800f80094426e8c08797654']])]
	
	# temporary dictonary, mapping a file to a list of version-hash-tuples
	tmpvectors = defaultdict(list)
	
	# bring them into the right format
	for v, hashlist in ret:
		# in case of an error (CRC fail, no permissions etc), there is an empty dict
		if hashlist:
			for name, h in hashlist:
				found = False
				if name in tmpvectors:
					for already_present_versions, hurrdurr, already_present_hash in tmpvectors[name]:
						if h == already_present_hash:
							already_present_versions.append(v)
							found = True
				if not found:
					tmpvectors[name].append([[v], 'hash', h])

	# put it into vector format
	vectors = [ make_vector(fname, tmpvectors[fname]) for fname in tmpvectors.keys() ]
	
	return vectors

if __name__ == "__main__":
	if len(sys.argv) < 2:
		print "usage: %s <files in tar>"%sys.argv[0]
		exit(-1)
	if "-q" in sys.argv:
		quiet=True
		sys.argv.remove("-q")
	print "vectors = ",
	pprint.pprint( hashlistify(sys.argv[1]) )
